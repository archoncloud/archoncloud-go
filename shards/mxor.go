package shards

// #cgo CFLAGS: -I../libs
// #cgo windows amd64 LDFLAGS: -L../libs/windows/amd64
// #cgo linux amd64 LDFLAGS: -L../libs/linux/amd64
// #cgo LDFLAGS: -lcodec_mxor
// #include <stdlib.h>
// #include <string.h>
// #include "mxor.h"
import "C"
import (
	"encoding/binary"
	"fmt"
	"github.com/dustin/go-humanize"
	"unsafe"
)

// At most 4G in our data buffers
const DataLenBytes = 4

func numShards(code ErasureCodeType) int {
	switch code {
	case Mxor_2_3: return 2
	case Mxor_2_4: return 4
	case Mxor_2_6: return 6
	case Mxor_2_7: return 7
	default: return 0
	}
}

// encodedDataLen does a big endian encoding d data length
func encodedDataLen(dataLen uint32) []byte {
	dataLenBuf := make([]byte, DataLenBytes)
	binary.BigEndian.PutUint32(dataLenBuf, dataLen)
	return dataLenBuf
}

func encodedDataLenPtr(dataLen uint32) *byte {
	return &encodedDataLen(dataLen)[0]
}

func decodedDataLen( u unsafe.Pointer ) uint32 {
	dataLenBuf := make([]byte, DataLenBytes)
	for i := 0; i < DataLenBytes; i++ {
		dataLenBuf[i] = *(*byte)(unsafe.Pointer(uintptr(u) + uintptr(i)))
	}
	return binary.BigEndian.Uint32(dataLenBuf)
}

func copyDataToC( u unsafe.Pointer, data []byte, dataLen uint32) {
	C.memcpy(unsafe.Pointer(uintptr(u)+uintptr(DataLenBytes)), unsafe.Pointer(&data[0]), C.size_t(dataLen))
}

// EncodeMxor returns a slice of shards encoded by the codec
func EncodeMxor(data []byte, code ErasureCodeType) ([][]byte, error) {
	l := len(data)
	// mxor limited to 4G
	maxLen := 1 << 32
	if l >= maxLen {
		return nil, fmt.Errorf("data is too large (%s). Max allowed=%s",
			humanize.Bytes(uint64(l)), humanize.Bytes(uint64(maxLen)))
	}
	dataLen := uint32(l)
	nShards := numShards(code)
	if nShards == 0 {
		return nil, fmt.Errorf("unknown code %v", code)
	}

	// Prepare input for C call
	inputPtr := C.malloc(C.sizeof_char * C.size_t(DataLenBytes+dataLen))
	if unsafe.Pointer(inputPtr) == nil {
		return nil, fmt.Errorf("insufficient memory, trying to allocate %s", humanize.Bytes(uint64(DataLenBytes+dataLen)))
	}
	defer C.free(unsafe.Pointer(inputPtr))
	// Copy the data length header
	C.memcpy(unsafe.Pointer(inputPtr), unsafe.Pointer(encodedDataLenPtr(dataLen)), C.size_t(DataLenBytes))
	// Now copy the data
	copyDataToC(inputPtr, data, dataLen)
/*
	// For debugging C code
	file, _ := os.Create("/tmp/mxor_encode_data.dat")
	defer file.Close()
	encodedDataLen := encodedDataLen(dataLen)
	file.Write(encodedDataLen)
	file.Write(data)
*/

	// Do the C call to encode
	blockOfShards := C.mxor_encode((*C.uchar)(inputPtr), C.enum_MXorCode(code))

	if unsafe.Pointer(blockOfShards) == nil {
		return nil, fmt.Errorf("unimplemented encoding or encoding failed")
	}
	defer C.free(unsafe.Pointer(blockOfShards))

	// Separate the shards and build the Go Shard's
	dataBufs := make([][]byte, nShards)
	s := unsafe.Pointer(blockOfShards)
	for shardIx := 0; shardIx < nShards; shardIx++ {
		blen := decodedDataLen(s)
		s = unsafe.Pointer(uintptr(s) + uintptr(DataLenBytes))
		dataBufs[shardIx] = make([]byte, blen)
		C.memcpy(unsafe.Pointer(&dataBufs[shardIx][0]), s, C.size_t(blen))
		s = unsafe.Pointer(uintptr(s) + uintptr(blen))
	}
	return dataBufs, nil
}

// DecodeMxor returns the decoded data block as generated by the codec (may end with padded zeros)
func DecodeMxor( shard1 []byte, shard1Ix int, shard2 []byte, shard2Ix int, code ErasureCodeType) ([]byte, error) {
	shardSize := len(shard1)
	if shardSize != len(shard2) {
		return nil, fmt.Errorf("the 2 shards have different sizes")
	}
	// Create the C buffers
	needed := uint64(shardSize+DataLenBytes)
	shard1Ptr := C.malloc(C.sizeof_char * C.size_t(needed))
	if unsafe.Pointer(shard1Ptr) == nil {
		return nil, fmt.Errorf("insufficient memory, trying to allocate %s", humanize.Bytes(needed))
	}
	defer C.free(unsafe.Pointer(shard1Ptr))
	C.memcpy(unsafe.Pointer(shard1Ptr), unsafe.Pointer(encodedDataLenPtr(uint32(shardSize))), C.size_t(DataLenBytes))

	shard2Ptr := C.malloc(C.sizeof_char * C.size_t(needed))
	if unsafe.Pointer(shard2Ptr) == nil {
		return nil, fmt.Errorf("insufficient memory, trying to allocate %s", humanize.Bytes(needed))
	}
	defer C.free(unsafe.Pointer(shard2Ptr))
	C.memcpy(unsafe.Pointer(shard2Ptr), unsafe.Pointer(encodedDataLenPtr(uint32(shardSize))), C.size_t(DataLenBytes))
	// Copy the data
	copyDataToC(shard1Ptr, shard1, uint32(shardSize))
	copyDataToC(shard2Ptr, shard2, uint32(shardSize))

	// Do the C call to decode
	dataBlock := C.mxor_decode((*C.uchar)(shard1Ptr), C.int(shard1Ix), (*C.uchar)(shard2Ptr), C.int(shard2Ix), C.enum_MXorCode(code))

	if unsafe.Pointer(dataBlock) == nil {
		return nil, fmt.Errorf("shards decoding failed")
	}

	dataLen := decodedDataLen(unsafe.Pointer(dataBlock))
	data := make([]byte,dataLen)
	C.memcpy(unsafe.Pointer(&data[0]), unsafe.Pointer(uintptr(unsafe.Pointer(dataBlock)) + uintptr(DataLenBytes)), C.size_t(dataLen))
	return data, nil
}
